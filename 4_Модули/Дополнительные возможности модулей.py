#!/usr/bin/evn python
#! -*- coding: utf-8 -*-
_x = 11 #эту переменную с подчёркиванием пропустит при импортировании с помощью from*
#другие методы (import modul или from modul import _x) всё ещё импортируют её 

__all__ = ['x'] #from * будет копировать только имена, перечисленные в списке __all__
#имеет смысл использовать только с инструкцией from* (не эквивалентен объявлению закрытости)
#Python сначала ищет список__all__в модуле и копирует его
#имена вне зависимости от наличия в них подчеркиваний;

#если переменная__all_
#не определена, тогда from * копирует все имена, не содержащие одиночный ведущий символ подчеркивания


#from _future_ import #включение расширеных возможностей

file = open('test.py', 'w')
file.write('def ff():' + '\n')
file.write('    print("ВСЁ OK")' + '\n')
file.write('if __name__ == "__main__":' + '\n') #вызвать если открыт как программа если импортирован не вызивать
file.write('    ff()' + '\n')
file.write('else: ' + '\n')
file.write('    print("НЕ ТАК")')
file.close()

import test #Выполнит код при импортировании
import test as filed #использовать псевдоним 
filed.ff()
from test import ff as f #можно использовать чтобы сократить имя? Копирует пространство имён
f()

X = 'test'
test = __import__(X) #импорт модуля пришедшего строкой или можно так exec('import' + X)
test.ff()


#по умолчанию код модуля выполняется только один раз на процесс (при импортировании). ДА при импортирование код в модуле выполняется
#повторное импортирование ничего не даст, код из импортируемого модуля не выполнится
import imp
imp.reliad(test) #перезагрузить модуль
#Повторное выполнение кода файла модуля переписывает его существующее пространство имен, а не удаляет и воссоздает его

#Функция reload ожидает передачи имени объекта уже загруженного модуля, а потому7 вам нужно иметь успешно импортированный модуль, прежде чем перезагружать

'''
Как и с присваиванием функций, повторное присваивание скопированному 
имени не оказывает влияния на модуль, из которого было скопировано имя, 
но модификация разделяемого изменяемого объекта через скопированное 
имя может также изменить его в модуле, откуда оно копировалось


не существует какой-либо связи между именем, скопированным с помощью from, 
и файлом, откуда оно поступило. Чтобы действительно изменить глобальное имя в другом файле,
потребуется использовать оператор import:
'''

'''
#Аналог from
import module # Извлечь объект модуля
namel = module.namel # Копировать имена присваиванием
name2 = module.пате2
del module
'''


#код, набираемый в интерактивной подсказке, на самом деле попадает во встроенный модуль по имени _main__
#В Python вы всегда находитесь внутри модуля.



#Изменения языка, потенциально способные нарушить работу существующего кода, 
#обычно в Python вводятся постепенно. Они часто появляются как необязательные расширения, 
#которые по умолчанию отключены. Для включения таких расширений используется специальный оператор 
#import следующего вида:
#from __future__ import название_средства

'''
Для просмотра списка будущих языковых средств, которые можно импортировать, 
выполните вызов dir на модуле future__после его импортирования или поищите
соответствующие сведения в руководстве по библиотеке.
'''

#Размещение кода самотестирования в конце файла внутри проверки атрибута name_является,
# вероятно, наиболее часто применяемым и простым протоколом
#модульного тестирования в Python.

#стандартные библиотечные модули unittest и doctest предлагают много расширенных инструментов тестирования
#также в документации по модулям get opt,
#optparse и argparse в руководстве по стандартной библиотеке Python

'''
не забывайте о том, что такие настройки sys .path сохраняются только на протяжении функционирования
 сеанса или программы Python (формально процесса), где они были сделаны; после выхода из Python они 
 утрачиваются. Напротив, конфигурации пути поиска в переменной PYTHONPATH и файлах .pth находятся в 
 среде операционной системы, а не в выполняющейся программе Python, и потому более глобальны: 
     они подхватываются каждой программой на компьютере и существуют после ее завершения. В
      некоторых системах первый вариант может быть организован на основе пользователей, 
      а второй охватывать всю установку.
'''

