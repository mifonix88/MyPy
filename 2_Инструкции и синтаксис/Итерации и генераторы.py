#!/usr/bin/evn python
# -*- coding: utf-8 -*-

#цикл for, потому что итераторы работают внутри Python со скоростью скомпилированного кода С, 
#а версия с циклом while запускает байт-код Python через виртуальную машину Python


f = open('123.txt', 'a')
f.write('Записывает строку1\n')
f.write('Записывает строку2\n')
f.write('Записывает строку3\n')
f.close()

f = open('123.txt')
print(f.readline(), end='') #Возвращает одну строку, по достижению конца вернёт пустую строку
print(f.readline(), end='') #(X.__next__())или(next(X))Аналог,но при конце вернёт исключение StopIteration
print(f.readline(), end='')

for line in open('123.txt'): #тоже читает построчно (можно и с вайле"  но так бут быстрее)
    print(line, end='')

print(list(enumerate('qwerty'))) #смещение\значение
 
L = [1,2,3,4,5,6,7,8,9]
print(L)
#Ручной вызов итераций
i = iter(L)
while True:
    try:
        X = next(i)
    except StopIteration:
        break
    print(X, end=' ')
print('\n')

#Генератор списка работает быстрее чем 
L = [i * 2 for i in L]
print(L)

E = [] #данный пример
for i in L:
    E.append(i + 10)
print(E)

C = [ x + y for x in '123' for y in 'abc'] #хитрое использование ген.цикла
print(C)

#Итерации при работе с файлами
f = open('123.txt')
X = f.readlines()
print(X)
f.close()

X = [i.rstrip() for i in open('123.txt')]  #rstrip()уберает пробельные символы в конце строки
print(X)


Z = [i.rstrip() for i in open('123.txt') if i[0] == '1'] #if i[0] == '1' включить в список только те строки которые начинаются с 1 
print(Z)

'&&'.join(open('123.txt'))
print(tuple(open('123.txt')))
print(list(open('123.txt')))
print(sorted(open('123.txt')))
print(list(zip(open('123.txt'))))
print(list(enumerate(open('123.txt'))))
print(list(filter(bool, open('123.txt'))))


import functools, operator
print(functools.reduce(operator.add, open('123.txt')))

#прочие итерируемые
print(sum([1,2,3])) #Суммма всех обьектов итерации
print(any([1,[],[]])) #тру если хоть один истина иначе фальс
print(all([1,4,''])) #тру если все истенны иначе фальс
print(max([1,2,3])) #максимальный элемент итерации
print(min([1,2,3])) #минималиный

#Генератор словаря
set(open('123.txt'))
print({i:x for (i,x) in enumerate(open('123.txt')) if x[0] != '1'})

#аргументы также итерируемые
def f(q,w): print('Ok')
f(*[1,2]) #Распоковка списка в аргументы

#Распаковка кортежа функции зип с помощью другой функции зир
X = (1,2)
Y = (3,4)
print(list(zip(X,Y)))
A,B = zip(*zip(X,Y))
print(A)
print(B)

#Фильтер возвращает те значения что тру
print(list(filter(bool,['we','',1])))

# Сортировка ключей словаря
D = dict(a=1, b=2, c=3)
print(D)
for i in sorted(D): #Лучший метод сортировки словорей
    print(i, D[i], end=' ')

print('\n')

#Итерации при работе с файлами
#
f = open('123.txt') #по сути опен возвращает итератор значит с ним можно работать как с итератором
print('######',next(f))
print('######',next(f))#функция next вызывает f.__next__()
print('######',next(f)) 
#генерирует исключение Stop Iteration при достижении конца
f.close()

#файловый объект является итератором сам по себе
#файловый объект имеет собственный метод _next__и не 
#нуждается в возвращении особого объекта, который предоставлял бы этот метод:
f = open('123.txt')
print(iter(f) is f)
f.close()

R = range(10) #range не является итератором (итератор создается вручную с помощью iter)
print(R)
I = iter(R)#Создание итератора из итерируемого объекта range
print(next(I))
print(next(I))
print(next(I))
print(len(R))

'''
Цикл for использует протокол итерации для прохода по элементам в итерируемом
объекте, который участвует в итерации. Сначала он извлекает итератор из итерируемого объекта, передавая объект встроенной функции iter, а затем на каждой итерации вызывает метод__next__объекта итератора в Python З.Х
и перехватывает исключение Stop Iteration для определения, когда останавливать выполнение цикла.

К итерационным контекстам в Python относятся цикл for, списковые включения, встроенная функция 
тар, выражение проверки членства in, а также встроенные функции sorted, sum, any и all. 
В эту категорию также входят встроенные функции list и tuple,
 строковые методы join и присваивания последовательностей — все они используют протокол итерации 
 (см. ответ на вопрос 1) для прохода по итерируемым объектам по одному элементу за раз.
'''
