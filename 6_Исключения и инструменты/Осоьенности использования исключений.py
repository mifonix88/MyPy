#!/usr/bin/evn python
# -*- coding: utf-8 -*-
class NovoeIskluchenie(Exception):#создать новое исключене
    pass

class NewErr2(Exception):#создать новое исключене
    pass


def fun():
    raise NovoeIskluchenie #Вызвать исключение

try:
    fun()
except NameError: #перехватить(просто эксцепт без названия исключения перехватывает любые исключения!!! а если там Exception то все кроме закрытия программы)
    print('lkz ghbvthf')
except NovoeIskluchenie: #перехватить(просто эксцепт без названия исключения перехватывает любые исключения!!! а если там Exception то все кроме закрытия программы)
    print('Оппа')
else:
    print('Исключений не возникло')#Выполница если исключений не возникло
finally:
    print('Оп па па)')#Выполница при любом раскладе
    
'''
try:
    raise IndexError('Сохранить некое значение')
except IndexError as Q:#присвоить экземпляр исключения переменной
    raise #Возбудить предидущие исключение
'''

#assert (утверждение) Возбуждает исключение AssertionError по условию
#Утверждения обычно используются для того, чтобы контролировать соблюдение
#условий в программах на стадии разработки.


#with Определяет действа до и после выполнения блока

'''
флаг__ debug__ — встроеннoe имя, которое автоматически устанавливается
в True, если только не используется флаг -О. Применяйте командную строку вроде
python -О main.py для запуска программы в оптимизированном режиме и отключения
(а потому пропуска) утверждений.
'''

def func(a,b):
    '''
    assert test, data # Часть data является необязательной
    работает аналогично следующему коду:
    if __debug__:
        if not test:
            raise AssertionError(data)
    '''
    assert a !=0 and b !=0 #если false то вызовет AssertionError
    return a/b 

print(func(2,1))


'''
#методы Asser
assertEqual(x, y)	x == y	

assertNotEqual(x, y)	x != y	

assertTrue(x)	bool(x) равно True	

assertFalse(x)	bool(x) равно False	

assertIs(x, y)	x это y	3.1

assertIsNot(x, y)	x это не y	3.1

assertIsNone(x)	x это None	3.1

assertIsNotNone(x)	x это не None	3.1

assertIn(x, y)	x в y	3.1

assertNotIn(x, y)	x не в y	3.1

assertIsInstance(x, y)	isinstance(x, y)	3.2

assertNotIsInstance(x,y)	не isinstance(x, y)
'''
##############
'''
Исключения иногда могут генерироваться в ответ на другие исключения

Когда конструкция from используется в явном запросе raise, следующее за from
выражение указывает еще один класс или экземпляр для присоединения к атрибуту
__ cause__ нового генерируемого исключения.
'''
def func2(arg):
    raise NovoeIskluchenie from NewErr2 

try:
    func2(45)
except(NovoeIskluchenie) as arg:
    print(type(arg))
#raise новое-исключение from другое-исключение
try:
    while True:
        print(1)
        
        while True:
            print(2)
            
            while True:
                print(3)
                for i in range(10):
                    if i == 5:
                        raise NovoeIskluchenie

except(NovoeIskluchenie):
    print('исключение позваляет завершить все цыклы break завершает только текущий')
    
print(i)#Вдобавок обратите внимание, что переменная i остается такой же, какой она
#была после выхода из оператора try. Присваивания переменных, выполненные внутри
#try, в общем случае не отменяются,
'''
Формально локальные переменные активных функций выталкиваются
из стека вызовов и в результате объекты, на которые они ссылаются, могут быть подвергнуты
сборке мусора, но такой шаг выполняется автоматически.
'''



try:
    '''...запуск программы...'''
    raise NovoeIskluchenie
except: # Сюда поступают все неперехваченные исключения
    import sys
    print('Инфа об исключениях', sys.exc_info()) #Это особенно полезно при использовании пустой конструкции except
#Такая структура обычно применяется на этапе разработки для сохранения программ
#в активном состоянии даже после возникновения ошибок — внутри цикла она
#позволяет прогонять дополнительные тесты без необходимости в перезапуске
