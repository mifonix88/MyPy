#!/usr/bin/evn python
# -*- coding: utf-8 -*-

#список - упорядоченая изменяемая последовательность, представляют собой массивы ссылок на объекты

L = [121, 'qwe', 1.23]
print(L)
print(len(L)) #Покажит сколько строк в списке L
print(L[1]) #Покажит второй элемент списка
D =  L + [2,3,4,9]#Создаст новый список!!! D(Конкатинация со списком L) Список L при этом не меняется
print(D)
L.append('qwer') #Добавит в конец списка L строку
L.extend([56,22])
print(L)
p = L.count (121) # Количество вхождений
print(p)


L[:3] = [111,112] #удаление среза и замена
print(L)#
del(L[:2])#удалить срез
L[:0] = ['text'] #Добавление в начало
#L.extend('tet','tet') #Добавит несколько элементов
#L += ['tet','tet'] #Автоматом вызовет extend
print(L)
L.pop(3) #Удылит 3Й элемент списка L(тоже что del L[3])
print(L)
E = ['cc','bb','aa']
print(E)
E.sort() #Сортирует по возрастанию (не создаёт новый список модефецирует исходный)
print(E)
E.reverse() #Сортирует по убыванию (не создаёт новый список модефецирует исходный)
print(E)
W = [E,L,D] #Списки в списке))
print(W)
print(W[1]) #Обращение к 2му элементу списка W
print(W[1][2]) #бращение к 3Й строке 2го элемента списка W
DD = [c * 2 for c in 'qwerty'] #Дублирование символов в строке (генерирует список((list comprehension))
print(DD)

#С помощью генераторов можно создавать списки, множества и словари
q = [ord(x) for x in 'spaam']#Список кодов символов
print(q)
w = {ord(x) for x in 'spaam'} #Множества ликвидируют дубликаты 
print(w)
e = {x: ord(x) for x in 'spaam'} #Ключи словорей являются уникальными
print(e)

#О цыклах
qwe = [x ** 2 for x in [1,2,3,4,5]] #Создаст список со значениями квадратов списка
print(qwe)

ewq = []
for x in [1,2,3,4,5]:  #Аналог предыдущему
    ewq.append(x ** 2)
print(ewq)


Q1 = [1,2,3]
Q2 = Q1
Q1[0] = [321]
print(Q1,Q2)#изменение в Q1 привели к изменению в Q2
Q1 = [1,2,3]
Q2 = Q1[:]# А сдесь Q2 ссылается не на Q1 а на копию Q1
Q1[0] = [321]
print(Q1,Q2)

#однако копия среза не получится с словарями надо использовать
Q1 = [1,2,3]
import copy
Q2 = copy.copy(Q1) #Поверхносная копия
#Q2 = copy.deepcopy(Q1) #Копия всего, вложений  тп.
print(Q2)


print(3 in [1,2,3,4]) #Проверит есть ли три в списке
L = ['ert','wrt','tre']
print(L)
L[1] = 1 #Изменение по индексу
print(L)
L[0:3] = [1,2,3] #Изменение целого среза
print(L)
L[len(L):] = ['X'] #тоже что append(L)
print(L)
L[:0] = ['X'] #Добавит в начало списка
print(L)
L = ['aBd','ADF','cbs']
print(L)

L.sort() #Сортирует с учётом регистра
print(L)
L.sort(key=str.lower) #без учёта регистра
print(L)
L.sort(key=str.lower, reverse=True) #изменяет направление сортировки
print(L)
#sort и append изменяют сам обьект в следствии возвращают None  а не новый список!
R = sorted(L, key=str.lower)#Встроеная функция сортировки
print(R)
R = sorted([x.lower() for x in L], reverse=True) #Сортирует и меняет регистр 
print(R)
#sorted оригенальный список не изменяет (возвращает новый список)

L.extend(['qwe'])
print(L) #Добавляет элементы в конец списка
print(L.pop())#Удаляет последний элемент списка и возвращает его значение
print(L.index('ADF'))#Индекс обьекта
L.insert(0, 'ytre')#вставка по индексу
print(L)
L.remove('ytre')#удаление элемента с определённым значением
print(L)
L.pop(1)#удаление из позиции 
print(L)

#положительные индексы считаются слева, а отрицательные — справа:
a = [1,2,3]
print(a[-1])

#X [I: J], означает “предоставить из X все содержимое, начиная со смещения I и заканчивая смещением J, не включая его”

q = (i for i in range(10)) #помеща списковые включения в круглые, создаётся генератор 
#списковыми включениями так же можно построить множества (), словари {}
print(next(q))
print(next(q))
print(next(q))
