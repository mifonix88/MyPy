#!/usr/bin/evn python
# -*- coding: utf-8 -*-
#Функции могут изменять значения в вызывающей программе
#Через * можно в качестве аргумента отправить любой итерируемый обьект func(*open('name'))
a = 77
b = 77
def fun(a,b):
    a=88
    b=99
fun(a,b)
print(a,b)
#однако

a=[77,77]
b = 77
def fun(a,b): #изменяемые объекты будут меняться
    a[0]=88
    b=99
fun(a,b)
print(a,b)

def fun(a,b=[]): #!!!!!!!!!!
    b.append(a)
    print(b)
fun(1)
fun(1)


def func(*X): #Формат * позволяет передавать функции неограниченое кол-во аргументов
    A = X * 2 #ТОже что (242,'qwer') * 2
    print(A)
func(124,'qwer')

#необязательные аргументы
def func1(a,b=2,c=6): #Если не передать значение б и ц то они примут значения по умолчанию 2 и 6 соотвептственно
    print(a,b,c)
func1(1)
func1(1,1)
func1(1,1,1)
func1(1, c=99)#можно указать явно при вызове какойменять

#преобразует аргументы в словарь
def f(**X):
    print(X)
f(a=123,r=12432)

#Для сложных сигнатур можно комбинировать
def ff(a,*b,**c):
    print(a,b,c)
ff(1,2,3, x=2,y=3)
Q = (1,1,1)
func1(Q)
func1(*Q) #Знак * при вызове распаковвывает картеж

def func2(a,*,b,c=999): #Всё что за *  должно быть именовано и только 2шт, а первый как угодно можно передать
    print(a,b,c)        #си же можно и по умолчанию
func2(3,b=4)

def func3(a, *b, c=99, **d):
    print(a,b,c,d)

func3(1,*(2,3),**dict(x=5,u=6,c=98)) #Распаковка словаря при вызове функции


#Функция поиска минимума 
def OkOk(*ok):
    if ok: return min(ok)


def func(arg=None):
    x = arg or [] #or вернёт arg если от True альтернатива if 
    x.append(2)
    return x

print(func([3]))
print(func())

#интроспекция функций
def func(а, Ь, с, e=True, f=None): # Аргументы: три обязательных,:
    print(a,b,c)
    
code = func.__code__ # Объект кода объекта функции
allargs = code.co_varnames  # Все имена локальных переменных
arg = code.co_varnames[:code.co_argcount] # <== Первые N имен локальных переменных
print(code, allargs, arg)
