#!/usr/bin/evn python
# -*- coding: utf-8 -*-

#классы (и экземпляры классов) являются изменяемыми объектами

#Поиск происходит снизу в верх с лева на право в дереве наследования
'''
Если ссылка 12.w представляет собой вызов функции, тогда в действительности
она означает “вызвать функцию класс СЗ.w для обработки 12. То есть Python будет автоматически
отображать вызов 12.w() на вызов СЗ.w(12), передавая унаследованной
функции экземпляр в первом аргументе.(self)
'''



class PervyiKlass():
    def func(self,qwerty): #функции внутри класса это методы класса
        self.func = qwerty
    def func2(self):
        print(self.func)

x = PervyiKlass() #обьект 'x' наследует класс 
y = PervyiKlass()

x.func('оббана') #эквивалентно PervyiKlass func(x, 'оббанна')
y.func(33)

y.func2()
x.func2()

#методы класс можно вызывать не только через экземпляр но и через сам клас 
#в качестве аргумента передовая экземпляр
#Полезно при множественном наследовании
z = PervyiKlass()
PervyiKlass.func(z,'@@@@@')
PervyiKlass.func2(z)

class A():
    def func(self):
        print('A')
class B():
    def func(self):
        print('B')

class C(B,A): #C - объект пустого пространства имен
    pass

test = C()
test.func() #выведет B
A.func(test) #выыедет А
#При поиске имени Python проверяет экземпляр, затем его
#класс и, наконец, все суперклассы(унаследованые с лева на право) и останавливается при первом нахожнении


x.qwerty = 123#создание нового атрибута в экземпляре х
print(x.qwerty)

class VtoroiKlass(PervyiKlass): #код не менялся а результат изменился
    def func2(self): #этот класс переопределяет функцию (перегружает)
        print('теперь бут так = "%s"' % self.func)
a = VtoroiKlass()
a.func('привет')
a.func2()
#классы как и любые имена можно импортировать или обращатся к ним как к функциям имямодуля.имякласса() и тп


#перегрузка операторов спец методами___Х___ (Дандерметоды, магические методы)
#являются специальными привязками определяющими методы вызываются автоматически, 
#когда экземпляры встречаются во встроенных операциях или типах.

class TretiiKlass(VtoroiKlass): #наследует второй клас
    def __init__(self,odin): #вызывается из третьего # метод__ init__ часто вызывается вручную для запуска шагов инициализации в суперклассе
        self.func = odin
    def __add__(self,dva): #для выражения селф + два
        return TretiiKlass(self.func + dva)
    def __str__(self): #вызывается из принт(селф) стр()
        return '[TretiiKlass: %s]' % self.func
    def func3(self, dva): #изменяет сам обьект - обычный метод
        self.func *= dva

d = TretiiKlass('12345') #Вызвали новый метод (инит)
d.func2() #Унаследованый метод
print(d) #__str__Возвращает строку

f = d + '6789' #__add__создаёт новый экземпляр
f.func2()
print(f)

d.func3(10) #изменяется экземнляр непосредственно
print(d) 

#Самый простой класс
class One: pass
One.name = 'Anna'
print(One.name)
i = One()
j = One()
print(i.name,j.name)#оба экземпляра имеют доступ к атребутам класса
j.name = 'Anton'
print(One.name, i.name, j.name)#однако у каждого экземпляра своё пустое пространство имён

#У каждого экзепляра можно можно получить словарь со словарём его пространства имён
print(One.__dict__.keys())
print(list(i.__dict__.keys()))
print(list(j.__dict__.keys()))

#У каждого экземпляра можно проверить его родительский класс
print('@@@@@@@@', i.__class__)



#В классы и экземпляры также можно передать фунции (вне класса)
def func(self):
    return self.name.upper()
    
One.ups = func
print(i.ups())
