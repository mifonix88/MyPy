#Путь поиска при наследовании в ромбовидных схемах выполняется больше в
#манере сначала в ширину ~ Python сначала ищет в любых суперклассах справа
#от только что просмотренного и только потом поднимается к общему суперклассу
#вверху. Другими словами, поиск проходит по уровням, прежде чем двигаться
#вверх. Такой порядок поиска называется MRO нового стиля (Method Resolution
#Order


class A():
    attr = 'attr A'
    def func(self):
        print('func A')


class A2():
    attr = 'attr A2'

class B(A):#Переопределяет метод
    def func(self):
        print('func B')


class C(A): 
    attr = 'attr C'


class D(B, C):pass

class E(D, A2, C):pass #по сути предпочтение отдаётся первому D а последний игнорируется
#если убрать С из наследования то в А2 будет искать в последнею очередь
'''
наследовании основано на допущении о том,
что если вы подмешиваете класс С ниже в дереве, то вероятно намереваетесь захватить
его атрибуты, отдавая им предпочтение перед атрибутами из А. Также допускалось,
что класс С всегда должен переопределять атрибуты А во всех контекстах.
'''

x = D()

print(x.attr)#Ищет в х, D, В, С
x.func()

y = E()
print(y.attr)#Ищет в х, D, B, A2
print(E.__mro__)


#Чтобы не ебать голову
#вызывай напрямую
class F(D, A2):
    attr = A2.attr
    
    def func(self):
        A.func(self)

a=F()
print(a.attr)
a.func()
print(F.__mro__) #возвращает MR0 класса — порядок, в котором процедура наследования осуществляет поиск
print(F.mro())#тож самое
'''
Без правила поиска
MRO нового стиля в сценариях с множественным наследованием стандартные методы
в object всегда замещали бы переопределения в пользовательских классах, если
только переопределения не располагались бы в крайнем слева суперклассе
'''
